#!/bin/bash
# LPIC-1 Training - Main Validation Framework
# Validates objective completion, runs self-tests, tracks progress
# Usage: lpic-check <command> [options]

set -euo pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OBJECTIVES_DIR="${SCRIPT_DIR}/objectives"

# Configuration
LPIC_DIR="/opt/LPIC-1/data"
DB_FILE="${LPIC_DIR}/progress.db"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Symbols
PASS="✓"
FAIL="✗"
WARN="⚠"
INFO="ℹ"

# Output functions
print_pass() { echo -e "${GREEN}${PASS}${NC} $1"; }
print_fail() { echo -e "${RED}${FAIL}${NC} $1"; }
print_warn() { echo -e "${YELLOW}${WARN}${NC} $1"; }
print_info() { echo -e "${CYAN}${INFO}${NC} $1"; }
print_header() { echo -e "\n${BOLD}${BLUE}═══ $1 ═══${NC}\n"; }

# Check database exists
check_db() {
    if [[ ! -f "$DB_FILE" ]]; then
        print_fail "Progress database not found"
        print_info "Run: ./init-progress.sh"
        exit 1
    fi
}

# Show usage
usage() {
    cat << 'EOF'
LPIC-1 Training Validator

Usage: lpic-check <command> [options]

Commands:
  objective <id>       Check specific objective completion (e.g., 101.1)
  topic <num>          Check all objectives in a topic (e.g., 101)
  command <cmd>        Test proficiency with a command
  progress             Show overall training progress
  verify-packages      Verify all required packages are installed
  self-test            Run self-tests on the feedback system
  exam-mode            Start exam simulation mode

Options:
  -v, --verbose        Show detailed output
  -h, --help           Show this help message

Exam Mode Options:
  --time <minutes>     Set time limit (default: 90)
  --count <num>        Number of objectives to test (default: 10)
  --exam <type>        Exam type: 101, 102, or mixed (default: mixed)

Examples:
  lpic-check objective 101.1
  lpic-check topic 103 --verbose
  lpic-check progress
  lpic-check command grep
  lpic-check verify-packages
  lpic-check exam-mode --time 60 --count 5 --exam 101
EOF
}

# Sanitize input for SQL queries
sanitize_id() {
    local input="$1"
    # Only allow alphanumeric, dots, hyphens, underscores
    # shellcheck disable=SC2001  # Negated character class requires sed, not bash expansion
    echo "$input" | sed 's/[^a-zA-Z0-9._-]//g'
}

# Check single objective
check_objective() {
    local obj_id
    obj_id=$(sanitize_id "$1")
    local verbose="${2:-false}"

    check_db

    # Validate objective ID format
    if [[ ! "$obj_id" =~ ^[0-9]+\.[0-9]+$ ]]; then
        print_fail "Invalid objective ID format: $1"
        print_info "Expected format: XXX.Y (e.g., 101.1, 103.5)"
        exit 1
    fi

    # Validate objective exists
    local obj_title
    obj_title=$(sqlite3 "$DB_FILE" "SELECT title FROM objectives WHERE id='$obj_id';")
    if [[ -z "$obj_title" ]]; then
        print_fail "Unknown objective: $obj_id"
        print_info "Valid objectives: 101.1-101.3, 102.1-102.6, 103.1-103.8, 104.1-104.7, 105.1-105.2, 106.1-106.3, 107.1-107.3, 108.1-108.4, 109.1-109.4, 110.1-110.3"
        exit 1
    fi

    print_header "Objective $obj_id: $obj_title"

    # Check if objective validator script exists
    local validator="${OBJECTIVES_DIR}/${obj_id}.sh"
    if [[ -f "$validator" ]]; then
        # Run the validator
        if bash "$validator" "$verbose"; then
            print_pass "Objective $obj_id: All checks passed"

            # Update database
            sqlite3 "$DB_FILE" "UPDATE objectives SET completed=1, completed_at=datetime('now') WHERE id='$obj_id';"
            return 0
        else
            print_fail "Objective $obj_id: Some checks failed"
            return 1
        fi
    else
        # Fallback: check related commands exist
        print_info "Checking commands for objective $obj_id..."

        local total=0
        local passed=0

        while IFS= read -r cmd; do
            ((total++)) || true
            if command -v "$cmd" &>/dev/null; then
                [[ "$verbose" == "true" ]] && print_pass "Command found: $cmd"
                ((passed++)) || true
            else
                [[ "$verbose" == "true" ]] && print_fail "Command missing: $cmd"
            fi
        done < <(sqlite3 "$DB_FILE" "SELECT command FROM commands WHERE objective_id='$obj_id';")

        if [[ $total -eq 0 ]]; then
            print_warn "No commands defined for this objective"
            return 0
        fi

        echo
        print_info "Commands: $passed/$total available"

        if [[ $passed -eq $total ]]; then
            print_pass "All commands for $obj_id are available"
            return 0
        else
            print_warn "Some commands missing - install required packages"
            return 1
        fi
    fi
}

# Check all objectives in a topic
check_topic() {
    local topic="$1"
    local verbose="${2:-false}"

    check_db

    print_header "Topic $topic Objectives"

    local objectives
    objectives=$(sqlite3 "$DB_FILE" "SELECT id FROM objectives WHERE topic='$topic' ORDER BY number;")

    if [[ -z "$objectives" ]]; then
        print_fail "No objectives found for topic $topic"
        exit 1
    fi

    local total=0
    local passed=0

    while IFS= read -r obj_id; do
        ((total++)) || true
        if check_objective "$obj_id" "$verbose"; then
            ((passed++)) || true
        fi
        echo
    done <<< "$objectives"

    print_header "Topic $topic Summary"
    print_info "Objectives passed: $passed/$total"

    if [[ $passed -eq $total ]]; then
        print_pass "Topic $topic complete!"
        return 0
    else
        print_warn "Topic $topic incomplete"
        return 1
    fi
}

# Test command proficiency
test_command() {
    local cmd="$1"

    check_db

    if ! command -v "$cmd" &>/dev/null; then
        print_fail "Command not found: $cmd"
        return 1
    fi

    print_header "Testing: $cmd"

    # Get objective for this command
    local obj_id
    obj_id=$(sqlite3 "$DB_FILE" "SELECT objective_id FROM commands WHERE command='$cmd' LIMIT 1;")

    if [[ -n "$obj_id" ]]; then
        print_info "Related to objective: $obj_id"
    fi

    # Basic existence check
    print_pass "Command exists: $(command -v "$cmd")"

    # Show man page availability
    if man -w "$cmd" &>/dev/null; then
        print_pass "Manual page available"
    else
        print_warn "No manual page found"
    fi

    # Update practice count
    sqlite3 "$DB_FILE" "UPDATE commands SET attempts = attempts + 1, last_practiced = datetime('now') WHERE command='$cmd';"

    echo
    print_info "Practice exercises:"
    case "$cmd" in
        grep)
            echo "  1. Find all lines containing 'error' in /var/log/syslog"
            echo "  2. Use -r to search recursively in a directory"
            echo "  3. Use -E for extended regex patterns"
            ;;
        find)
            echo "  1. Find all .conf files in /etc"
            echo "  2. Find files modified in the last 24 hours"
            echo "  3. Find and delete files matching a pattern"
            ;;
        ps)
            echo "  1. Show all processes with full details (ps aux)"
            echo "  2. Show process tree (ps axjf)"
            echo "  3. Show processes for a specific user"
            ;;
        *)
            echo "  Try: $cmd --help"
            echo "  Try: man $cmd"
            ;;
    esac
}

# Show progress summary
show_progress() {
    local detailed="${1:-false}"

    check_db

    print_header "LPIC-1 Training Progress"

    # Overall progress
    local total completed
    total=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM objectives;")
    completed=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM objectives WHERE completed=1;")
    local percent=$((completed * 100 / total))

    echo -e "${BOLD}Overall Progress:${NC} $completed/$total objectives ($percent%)"
    echo

    # Progress bar
    local bar_width=40
    local filled=$((bar_width * completed / total))
    local empty=$((bar_width - filled))

    printf "["
    printf "%${filled}s" | tr ' ' '█'
    printf "%${empty}s" | tr ' ' '░'
    printf "] %d%%\n\n" "$percent"

    # Topic breakdown
    echo -e "${BOLD}By Topic:${NC}"
    sqlite3 -column -header "$DB_FILE" << 'SQL'
SELECT
    topic as Topic,
    COUNT(*) as Total,
    SUM(completed) as Done,
    ROUND(100.0 * SUM(completed) / COUNT(*), 0) || '%' as Progress
FROM objectives
GROUP BY topic
ORDER BY topic;
SQL

    if [[ "$detailed" == "true" ]]; then
        echo
        echo -e "${BOLD}Incomplete Objectives:${NC}"
        sqlite3 -column -header "$DB_FILE" << 'SQL'
SELECT number as Objective, title as Title, weight as Weight
FROM objectives
WHERE completed = 0
ORDER BY number
LIMIT 10;
SQL

        echo
        echo -e "${BOLD}Recently Practiced Commands:${NC}"
        sqlite3 -column -header "$DB_FILE" << 'SQL'
SELECT command as Command, attempts as Attempts, last_practiced as 'Last Practice'
FROM commands
WHERE last_practiced IS NOT NULL
ORDER BY last_practiced DESC
LIMIT 10;
SQL
    fi

    echo
    print_info "Next suggested objective:"
    local next_obj
    next_obj=$(sqlite3 "$DB_FILE" "SELECT number || ': ' || title FROM objectives WHERE completed=0 ORDER BY weight DESC, number LIMIT 1;")
    echo "  $next_obj"
}

# Verify all required packages
verify_packages() {
    print_header "Package Verification"

    local total=0
    local found=0
    local missing=()

    # Key commands to check
    local commands=(
        # 101
        "lspci" "lsusb" "lsmod" "modprobe" "dmesg" "systemctl"
        # 102
        "dpkg" "apt" "rpm" "dnf" "grub-mkconfig" "fdisk" "pvcreate"
        # 103
        "find" "grep" "sed" "awk" "tar" "gzip" "ps" "kill" "vim"
        # 104
        "mkfs.ext4" "mkfs.xfs" "mount" "umount" "chmod" "chown" "ln"
        # 105
        "bash"
        # 106
        "xauth"
        # 107
        "useradd" "crontab" "at"
        # 108
        "chronyc" "logger" "lpstat"
        # 109
        "ip" "ss" "dig" "ping" "traceroute"
        # 110
        "ssh" "gpg" "sudo" "iptables"
    )

    for cmd in "${commands[@]}"; do
        ((total++)) || true
        if command -v "$cmd" &>/dev/null; then
            ((found++)) || true
        else
            missing+=("$cmd")
        fi
    done

    print_info "Checked $total essential commands"
    print_pass "Found: $found"

    if [[ ${#missing[@]} -gt 0 ]]; then
        print_fail "Missing: ${#missing[@]}"
        echo
        echo "Missing commands:"
        for cmd in "${missing[@]}"; do
            echo "  - $cmd"
        done
        echo
        print_info "Run the appropriate install script to install missing packages"
        return 1
    else
        print_pass "All essential commands available!"
        return 0
    fi
}

# Run self-tests
self_test() {
    print_header "Feedback System Self-Test"

    local tests_run=0
    local tests_passed=0

    # Test 1: Database exists
    ((tests_run++)) || true
    if [[ -f "$DB_FILE" ]]; then
        print_pass "Database exists"
        ((tests_passed++)) || true
    else
        print_fail "Database missing"
    fi

    # Test 2: Database has objectives
    ((tests_run++)) || true
    local obj_count
    obj_count=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM objectives;" 2>/dev/null || echo "0")
    if [[ "$obj_count" -gt 0 ]]; then
        print_pass "Database has $obj_count objectives"
        ((tests_passed++)) || true
    else
        print_fail "No objectives in database"
    fi

    # Test 3: Database has commands
    ((tests_run++)) || true
    local cmd_count
    cmd_count=$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM commands;" 2>/dev/null || echo "0")
    if [[ "$cmd_count" -gt 0 ]]; then
        print_pass "Database has $cmd_count commands"
        ((tests_passed++)) || true
    else
        print_fail "No commands in database"
    fi

    # Test 4: Objectives directory exists
    ((tests_run++)) || true
    if [[ -d "$OBJECTIVES_DIR" ]]; then
        print_pass "Objectives directory exists"
        ((tests_passed++)) || true
    else
        print_warn "Objectives directory missing (validators not available)"
    fi

    # Test 5: SQLite working
    ((tests_run++)) || true
    if sqlite3 "$DB_FILE" "SELECT 1;" &>/dev/null; then
        print_pass "SQLite queries working"
        ((tests_passed++)) || true
    else
        print_fail "SQLite query failed"
    fi

    echo
    print_header "Self-Test Results"
    print_info "Tests passed: $tests_passed/$tests_run"

    if [[ $tests_passed -eq $tests_run ]]; then
        print_pass "All self-tests passed!"
        return 0
    else
        print_warn "Some tests failed"
        return 1
    fi
}

# Exam simulation mode
exam_mode() {
    check_db

    local time_limit=90
    local num_objectives=10
    local exam_type="mixed"

    # Parse exam-mode options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --time)
                time_limit="$2"
                shift 2
                ;;
            --count)
                num_objectives="$2"
                shift 2
                ;;
            --exam)
                exam_type="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    print_header "LPIC-1 Exam Simulation"

    echo -e "${BOLD}Exam Configuration:${NC}"
    echo "  Time limit: $time_limit minutes"
    echo "  Objectives: $num_objectives"
    echo "  Type: $exam_type (101=Exam 101, 102=Exam 102, mixed=both)"
    echo

    # Get objectives based on exam type
    local objectives_query
    case $exam_type in
        101)
            objectives_query="SELECT id, weight FROM objectives WHERE topic BETWEEN 101 AND 104 ORDER BY RANDOM() LIMIT $num_objectives;"
            ;;
        102)
            objectives_query="SELECT id, weight FROM objectives WHERE topic BETWEEN 105 AND 110 ORDER BY RANDOM() LIMIT $num_objectives;"
            ;;
        *)
            objectives_query="SELECT id, weight FROM objectives ORDER BY RANDOM() LIMIT $num_objectives;"
            ;;
    esac

    # Get random objectives with weights
    local exam_objectives
    exam_objectives=$(sqlite3 "$DB_FILE" "$objectives_query")

    if [[ -z "$exam_objectives" ]]; then
        print_fail "Could not load objectives"
        exit 1
    fi

    # Calculate total weight and passing threshold
    local total_weight=0
    local objectives_list=()
    local weights_list=()

    while IFS='|' read -r obj_id weight; do
        objectives_list+=("$obj_id")
        weights_list+=("$weight")
        ((total_weight += weight)) || true
    done <<< "$exam_objectives"

    local passing_score=$((total_weight * 65 / 100))  # 65% to pass

    echo -e "${BOLD}Exam Objectives:${NC}"
    for i in "${!objectives_list[@]}"; do
        local obj_title
        obj_title=$(sqlite3 "$DB_FILE" "SELECT title FROM objectives WHERE id='${objectives_list[$i]}';")
        echo "  ${objectives_list[$i]}: $obj_title (weight: ${weights_list[$i]})"
    done
    echo
    echo "Total weight: $total_weight"
    echo "Passing score: $passing_score ($((passing_score * 100 / total_weight))%)"
    echo

    # Confirm start
    echo -e "${YELLOW}Press ENTER to start the exam timer, or Ctrl+C to cancel${NC}"
    read -r

    # Record start time
    local start_time
    start_time=$(date +%s)
    local end_time=$((start_time + time_limit * 60))

    print_header "Exam Started"
    echo "Started at: $(date)"
    echo "Time limit: $time_limit minutes"
    echo

    # Track scores
    local earned_weight=0
    local objectives_passed=0
    local objectives_failed=0

    # Run each objective
    for i in "${!objectives_list[@]}"; do
        local obj_id="${objectives_list[$i]}"
        local weight="${weights_list[$i]}"

        # Check remaining time
        local current_time
        current_time=$(date +%s)
        local remaining=$((end_time - current_time))

        if [[ $remaining -le 0 ]]; then
            echo
            print_fail "TIME'S UP!"
            break
        fi

        local remaining_min=$((remaining / 60))
        local remaining_sec=$((remaining % 60))

        echo
        echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}Objective $((i + 1))/${#objectives_list[@]}: $obj_id${NC}"
        echo -e "Time remaining: ${remaining_min}m ${remaining_sec}s"
        echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
        echo

        # Run the validator
        local validator="${OBJECTIVES_DIR}/${obj_id}.sh"
        if [[ -f "$validator" ]]; then
            if bash "$validator" "false" 2>/dev/null; then
                print_pass "Objective $obj_id: PASSED (+$weight points)"
                ((earned_weight += weight)) || true
                ((objectives_passed++)) || true
            else
                print_fail "Objective $obj_id: FAILED (0 points)"
                ((objectives_failed++)) || true
            fi
        else
            print_warn "No validator for $obj_id (skipped)"
        fi
    done

    # Calculate final score
    local final_time
    final_time=$(date +%s)
    local elapsed=$((final_time - start_time))
    local elapsed_min=$((elapsed / 60))
    local elapsed_sec=$((elapsed % 60))

    print_header "Exam Results"

    echo -e "${BOLD}Time:${NC}"
    echo "  Elapsed: ${elapsed_min}m ${elapsed_sec}s"
    echo "  Limit: ${time_limit}m"
    echo

    echo -e "${BOLD}Score:${NC}"
    echo "  Points earned: $earned_weight / $total_weight"
    local percentage=$((earned_weight * 100 / total_weight))
    echo "  Percentage: $percentage%"
    echo "  Passing score: $passing_score ($((passing_score * 100 / total_weight))%)"
    echo

    echo -e "${BOLD}Objectives:${NC}"
    echo "  Passed: $objectives_passed"
    echo "  Failed: $objectives_failed"
    echo

    # Progress bar
    local bar_width=40
    local filled=$((bar_width * earned_weight / total_weight))
    local empty=$((bar_width - filled))
    local pass_mark=$((bar_width * 65 / 100))

    printf "Score: ["
    for ((j=0; j<bar_width; j++)); do
        if [[ $j -eq $pass_mark ]]; then
            printf "|"
        elif [[ $j -lt $filled ]]; then
            printf "█"
        else
            printf "░"
        fi
    done
    printf "] %d%%\n" "$percentage"
    echo "        $(printf '%*s' $pass_mark '')↑ Pass (65%)"
    echo

    # Final result
    if [[ $earned_weight -ge $passing_score ]]; then
        echo -e "${GREEN}${BOLD}══════════════════════════════════════${NC}"
        echo -e "${GREEN}${BOLD}           EXAM PASSED!               ${NC}"
        echo -e "${GREEN}${BOLD}══════════════════════════════════════${NC}"
    else
        echo -e "${RED}${BOLD}══════════════════════════════════════${NC}"
        echo -e "${RED}${BOLD}           EXAM FAILED                ${NC}"
        echo -e "${RED}${BOLD}══════════════════════════════════════${NC}"
        echo
        print_info "Keep practicing! Focus on high-weight objectives."
    fi

    # Save exam result to database
    sqlite3 "$DB_FILE" "INSERT OR REPLACE INTO labs (lab_id, started_at, completed_at, score, hints_used) VALUES ('exam-$exam_type-$(date +%Y%m%d%H%M%S)', datetime('now', '-$elapsed seconds'), datetime('now'), $percentage, 0);" 2>/dev/null || true
}

# Export progress
export_progress() {
    check_db

    local output_file="${1:-progress-export.json}"

    sqlite3 "$DB_FILE" << SQL
.mode json
.output $output_file
SELECT
    o.id,
    o.topic,
    o.number,
    o.title,
    o.weight,
    o.completed,
    o.completed_at,
    (SELECT COUNT(*) FROM commands c WHERE c.objective_id = o.id AND c.attempts > 0) as commands_practiced
FROM objectives o
ORDER BY o.number;
SQL

    print_pass "Progress exported to $output_file"
}

# Main entry point
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    local verbose=false
    local command="$1"
    shift

    # Parse global options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                break
                ;;
        esac
    done

    case $command in
        objective)
            if [[ $# -lt 1 ]]; then
                print_fail "Usage: lpic-check objective <id>"
                exit 1
            fi
            check_objective "$1" "$verbose"
            ;;
        topic)
            if [[ $# -lt 1 ]]; then
                print_fail "Usage: lpic-check topic <num>"
                exit 1
            fi
            check_topic "$1" "$verbose"
            ;;
        command)
            if [[ $# -lt 1 ]]; then
                print_fail "Usage: lpic-check command <cmd>"
                exit 1
            fi
            test_command "$1"
            ;;
        progress)
            show_progress "$verbose"
            ;;
        verify-packages)
            verify_packages
            ;;
        self-test)
            self_test
            ;;
        exam-mode)
            exam_mode "$@"
            ;;
        export)
            export_progress "$@"
            ;;
        -h|--help)
            usage
            ;;
        *)
            print_fail "Unknown command: $command"
            usage
            exit 1
            ;;
    esac
}

main "$@"
